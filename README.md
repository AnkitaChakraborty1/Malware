Malware Details
File that the other teams shall need for analysis : group4_malware.exe
Source Code Filename : run_me.cpp, malware_mix.cpp
Malware Type: Dropper, Reverse Shell, Keylogger
Overview: group4_malware.cpp will load the binary compiled from group4_mix.cpp, which is a
dropper that installs and run a reverse shell and a keylogger on the target device without the
victim noticing it. Windows reverse shell is from where the attacker is able to send shell
commands. Keylogging malware is a program that can capture keyboard events and save to a
.txt file.
Techniques implemented:
1. Anti-Reverse Engineering / Anti-Analysis
Anti-disassembly techniques are used by malware authors to delay, prevent and/or avoid the
reverse-engineering of their code. It uses manually crafted code to cause disassembly analysis
tools to produce an incorrect program listing. Here are some common anti-disassembly
techniques used in our program
a. Check in Debug - Anti-Debug makes it harder for a malware analyst to perform
dynamic analysis on a malware. For this, we used the library function
“IsDebuggerPresent”. Commonly used as an anti-debugging trick, this function
aims to break the process whenever the program detects that it is being
debugged. It checks for the BeingDebugged flag in the PEB (Process
Environment Block) and returns a non-zero value if it is actually being
debugged. This function (“IsDebuggerPresent”) is also obfuscated as explained
in the Obfuscation section.
b. Check in VM - We conducted a quick poll on what VM software most students
are using. This gave us the insight that VirtualBox is used by a majority of the
class.
VMs running on VirtualBox have registry keys located at
“HARDWARE\\ACPI\\DSDT\\VBOX__”. Using RegOpenKeyEx for this location
confirms whether the VM is running on VirtualBox. RegOpenKeyEx opens a key
in the Windows registry. The handle it gives must be used when you read to or
write from any values under that key. The function returns 0 if successful, or a
non-zero value error code if an error occurred.
2. Persistence (Registry) - Persistence allows this malware to continue running after the
victim machine reboots. We achieved this by adding a registry key for the malware
program at "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run". The String used
for the registry location is also encoded using the method in the “Encoding” section of
this report. The filepath used is the concatenation of GetCurrentDirectory and our
executable name.
3. Mutex - Also referred to as a lock, mutex is a program object used to deter simultaneous
access to a resource. It allows multiple program threads to share the same resource in
concurrent programming.
Here we have used mutex to avoid the infection of the victim system by different
instances of the same malware. In our malware program we have a function called
CheckMutexExists() in which we create a uniquely named mutex using the
CreateMutex() function. CreateMutex() will succeed even if the mutex already exists, but
the GetLastError() function will return ERROR_ALREADY_EXISTS. This points out that
another instance of our application is in existence, because the mutex was created first
by that.
bool CheckMutexExists() {
CreateMutexA(0, FALSE, "foofoo");
return GetLastError() == ERROR_ALREADY_EXISTS;
}
C++ code for Mutex
4. Obfuscation
a. Main Program loaded from Resource - See “Dropper”. The main functionality
of the malware is stored as a separate program. The binary for this program is
stored as a Resource that is loaded and launched by the Dropper program.
b. Hidden Files - Windows provides a functionality for hidden files so that they do
not normally show on the filesystem. We achieved this by setting
FILE_ATTRIBUTE_HIDDEN when making calls to CreateFile.
c. Loading Windows Functions Dynamically - Some function imports such as
“IsDebuggerPresent” are very obvious what we are trying to do. We improved
obfuscation of these functions by using an encoded string to reference and load
some functions dynamically.
typedef UINT (CALLBACK* LPFNDLLFUNC1)();
HINSTANCE hDLL; // Handle to DLL
LPFNDLLFUNC1 lpfnDllFunc1; // Function pointer
hDLL = LoadLibrary("kernel32");
if (hDLL != NULL)
{
lpfnDllFunc1 = (LPFNDLLFUNC1) GetProcAddress(hDLL,
decoded_function_name);
return lpfnDllFunc1(); // call the function
}
else return true; //say this is on a debugger by default
C++ pseudocode for Loading Library Function Dynamically
d. Renamed Function Names - When loading our program into IDA Pro, we
noticed that our function calls were showing the names of our functions such as
“IsVM()”. To combat this, we changed our function names to something less
obvious such as changing “HasDebugger()” to “sub_50000()”. Here is the list of
how we changed our function names:
i. TestEnDecode - sub_10000
ii. IsVBOX - sub_50000
iii. HasDebugger - sub_60000
iv. CheckMutexExists - sub_70000
v. keyboardHookProc - sub_80000
vi. Shell - sub_90000
vii. GenRegKey - sub_22000
viii. CoverDrop - sub_45670
5. Dropper - A dropper is a type of loader, a file that is executed before malware is
executed to hide the current or future execution. It is identified as a "trojan" by many
malware programs because we can consider a dropper to be legitimate file until malware
is executed.
The main purpose that the dropper serves in this program is to install and run other
malicious codes on the target device without the victim noticing it. As opposed to
downloaders, which download malicious components from the attacker's server, the
dropper already contains the components.
To save as a new file, a new file pointer is obtained through the “CreateFile” api, and the
read payload is saved through the WriteFile api. In case of the dropper implemented in
this project, malicious payload is hidden in the Resource section. Therefore, the payload
in the resource can be loaded into memory through api commands such as
FindResource, SizeofResource, and LoadResource.
hResource = FindResource(..., CheckResource section, ….);
dwResSize = SizeofResource(..., hResource);
hResData = LoadResource(..., hResource);
If (Hidden executable file exists in Resource area) {
lpData = LockResource(hResData);
hFile = CreateFile(“malware.exe”, ….);
WriteFile(hFile, lpData, dwResSize, ….);
CreateProcess(....,”malware.exe”,....);
}
C++ pseudocode for dropper
6. Encoding/Decoding (XOR) - Encoding helps to make static analysis harder as they will
not show up in the Strings window of IDA Pro. Instead, bytes are loaded within the
assembly code and the malware analyst must do extra work in order to find the encoding
key. This malware uses a simple XOR encoding technique to encode a few of its more
obvious strings. The key used for this encoding is ‘A’ or 0x41. In order to make the key
harder to find, we have written the following function TestEnDecode()
char* TestEnDecode(char* val, int length) {
char* newString = (char*) malloc(sizeof(char) * (length + 1));
char key = 0x55;
key = 0x55 & 0x4B;
for(int i=0; i<length; i++) {
String[i] = val[i] ^ key; //'A'
} return newString;
}
C++ code for Decoding
With the above code, IDA Pro shows the following, which means that the decoding key is
not as obvious using static analysis.
7. Hooks - This is a tool offered by Windows API defined in their documentation as ” a
point in the system message-handling mechanism where an application can install a
subroutine to monitor the message traffic in the system and process certain types of
messages before they reach the target window procedure”. To put in simpler terms,
hooks enable interception of system messages and reaction according to those.
// Set windows hook
HHOOK keyboardHook = SetWindowsHookEx(
WH_KEYBOARD_LL,keyboardHookProc,hInstance,0);
A handle to a hook (HHOOK) has to be initialised using the SetWindowsHookEx
function. The first argument, WH_KEYBOARD_LL, indicates the kind of message that is
going to be monitored by our program, where ‘LL’ signifies Low Level (LL) information
received from the keyboard activity. The second argument, keyboardHookProc is the
hook procedure which is a user defined function defining what the hook will do.
The most important part in an application like this is the definition of the hook procedure.
As it’s common on the Windows API, this function can have any name as long it adheres
to the appropriate function prototype. For instance, a procedure called KeyboardProc
should look like this:
LRESULT CALLBACK keyboardHookProc(int nC
ode, WPARAM wParam, LPARAM lParam)
In case of unavailability of keyboard information, the variable nCode contains a number
smaller than 0. When information is available, wParam contains the type of message
received and lParam provides additional data.
In our program we are interested in the key down message (wParam ==
WM_KEYDOWN) which is triggered whenever a key is pressed.
Upon receipt of WM_KEYDOWN message, lParam contains a PKBDLLHOOKSTRUCT
which stores, the virtual-key code of the pressed key along with other information.
8. KeyLogger : A keylogger in its simplest state, tracks key presses that the keyboard
registers and then passes along to its destination. Keyloggers are not always considered
malware since it is dependent on the situation in which it is used. This program
implements a simple keylogger that captures all the Keyboard events and saves the
keys to a text file.
vkCode or Virtual Key codes are used by the system corresponding with the symbolic
constant names, hexadecimal values, and mouse or keyboard equivalents For example
VK_LBUTTON represents the Left mouse button. Our program registers these keyboard
events as invisible keys and the visible keys like the alphanumeric ones get typecasted
to lower-case and written into the text file
9. Reverse Shell
Reverse shell component is a simple component that consists of two functions. First
function, “Shell() , is what is being launched on the victim's machine. The reverse shell
utilizes winsock2.dll and wininet.dll. For simplicity it creates a server on the hardcoded IP
address on port 9001 and launches it’s window in the stealth mode.
The shell has a limited total_response buffer and returns the content of the entire buffer.
The image above was captured during testing and depicts the shell usage. Using ncat,
an attacker (which in our case is running on the same host) is able to connect to the
victim’s machine running our shell and list the content of a directory.
The remote shell listens to the special key inputs, and stops running if the “q” key is
passed on to it.
Instructions to test the Reverse shell:
Download and install nmap for Windows(ncat is packaged with it)
Open cmd.exe
Execute the command “ncat-lvp 9001” - attacker is listening for a connection
Run malware with ServIP to connect to 127.0.0.1(malware tries to connect to attacker
